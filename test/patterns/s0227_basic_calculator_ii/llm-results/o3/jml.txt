Thinking...Thinking...Thinking...Thinking...Thinking...Thinking... (1s elapsed)Thinking... (1s elapsed)Thinking... (1s elapsed)Thinking... (1s elapsed)Thinking... (1s elapsed)Thinking... (2s elapsed)Thinking... (2s elapsed)Thinking... (2s elapsed)Thinking... (2s elapsed)Thinking... (2s elapsed)Thinking... (3s elapsed)Thinking... (3s elapsed)Thinking... (3s elapsed)Thinking... (3s elapsed)Thinking... (3s elapsed)Thinking... (4s elapsed)Thinking... (4s elapsed)Thinking... (4s elapsed)Thinking... (4s elapsed)Thinking... (4s elapsed)Thinking... (5s elapsed)Thinking... (5s elapsed)Thinking... (5s elapsed)Thinking... (5s elapsed)Thinking... (5s elapsed)Thinking... (6s elapsed)Thinking... (6s elapsed)Thinking... (6s elapsed)Thinking... (6s elapsed)Thinking... (6s elapsed)Thinking... (7s elapsed)Thinking... (7s elapsed)Thinking... (7s elapsed)Thinking... (7s elapsed)Thinking... (7s elapsed)Thinking... (8s elapsed)Thinking... (8s elapsed)Thinking... (8s elapsed)Thinking... (8s elapsed)Thinking... (8s elapsed)Thinking... (9s elapsed)Thinking... (9s elapsed)Thinking... (9s elapsed)Thinking... (9s elapsed)Thinking... (9s elapsed)Thinking... (10s elapsed)Thinking... (10s elapsed)Thinking... (10s elapsed)Thinking... (10s elapsed)Thinking... (10s elapsed)Thinking... (11s elapsed)Thinking... (11s elapsed)Thinking... (11s elapsed)Below is an (implementation-independent) JML contract for a Java method  

    public static /*@ pure @*/ int calculate(String s)

that solves “LeetCode 227 – Basic Calculator II”.

```java
public class BasicCalculatorII {

    /*@ public normal_behavior
      @   requires s != null;
      @
      @   // Size constraint coming from the statement
      @   requires 1 <= s.length() && s.length() <= 3 * 100000;
      @
      @   // Only the characters allowed by the exercise may occur
      @   requires (\forall int i; 0 <= i && i < s.length();
      @                Character.isDigit(s.charAt(i))      ||
      @                s.charAt(i) == '+' || s.charAt(i) == '-' ||
      @                s.charAt(i) == '*' || s.charAt(i) == '/' ||
      @                s.charAt(i) == ' ');
      @
      @   // "s represents a valid expression" -----------------------------
      @   // We delegate the formal definition of *valid* to the pure
      @   // model predicate validExpr below ; the requirement expresses
      @   // exactly the natural-language promise made by the statement.
      @   requires validExpr(s);
      @
      @   // Because the statement guarantees that every intermediate
      @   // result as well as the final answer fits in a 32-bit signed
      @   // integer, the method may return any Java int value.
      @   ensures Integer.MIN_VALUE <= \result && \result <= Integer.MAX_VALUE;
      @
      @   // Semantic post-condition:  the returned value is *the* value of
      @   // the arithmetic expression that s denotes, according to the
      @   // usual precedence (* and / before + and −, left-to-right) and
      @   // with integer division truncating toward zero.  〈eval〉 is a
      @   // ghost (model) function that captures that meaning.
      @   ensures \result == eval(s);
      @
      @   // The method is functionally pure:  it allocates nothing, writes
      @   // to no object fields and has no other side effect.
      @   assignable \nothing;
      @*/
    public /*@ pure @*/ static int calculate(String s) {
        /* implementation not shown */
    }
    
    
    /*------------------------------------------------------------------*/
    /*                Auxiliary ghost specification elements            */
    /*------------------------------------------------------------------*/

    /*@  // “valid expression” predicate used in the pre-condition above
      @ public pure model boolean validExpr(String expr);
      @*/

    /*@   // Denotational semantics of an expression (left-to-right,
      @     // * / precedence and division truncating toward zero).
      @   public pure model int eval(String expr);
      @*/
}
```

Explanations of the individual clauses:

• `requires s != null;` — the method must not be invoked with a null reference.  
• `requires 1 <= s.length() <= 3 × 10⁵;` — length constraint from the exercise.  
• The character-set `requires` clause captures “s consists of integers and the operators '+', '-', '*', '/' separated by spaces”.  
• `requires validExpr(s);` summarizes the many syntactic rules (operator placement, digit groups not exceeding 2³¹−1, etc.) that the exercise says are guaranteed.  They are moved into a pure model predicate rather than being spelled out literally.  
• `ensures \result == eval(s);` is the real semantic contract: the method must return exactly the mathematical value defined by the model function `eval`.  (How `eval` is defined is irrelevant to clients; any sound, terminating Java implementation that fulfills the equality is correct.)  
• `assignable \nothing;` advertises that the method is side-effect-free; combined with the keyword `pure` it can be used in other specifications.

These JML annotations translate the entire natural-language problem statement into a precise formal contract without dictating any particular algorithmic strategy or exposing implementation details.